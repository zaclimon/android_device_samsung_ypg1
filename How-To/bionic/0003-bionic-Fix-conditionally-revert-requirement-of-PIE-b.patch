From fdef7ac2f07fdcf088f483605528d153fb7ce621 Mon Sep 17 00:00:00 2001
From: mar-v-in <github@rvin.mooo.com>
Date: Tue, 10 Mar 2015 19:23:05 +0100
Subject: [PATCH 3/4] bionic: Fix "conditionally revert requirement of PIE
 binaries" for 5.1

Change-Id: I49821d27d3784a914157df165feb63cf18c9dba1
---
 linker/linker.cpp | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/linker/linker.cpp b/linker/linker.cpp
index e92390f..d1f3469 100644
--- a/linker/linker.cpp
+++ b/linker/linker.cpp
@@ -1475,10 +1475,10 @@ int soinfo::Relocate(ElfW(Rel)* rel, unsigned count) {
              * R_ARM_COPY may only appear in executable objects where e_type is
              * set to ET_EXEC.
              */
-            DL_ERR("%s R_ARM_COPY relocations are not supported", si->name);
+            DL_ERR("%s R_ARM_COPY relocations are not supported", name);
             return -1;
 #else
-            if ((si->flags & FLAG_EXE) == 0) {
+            if ((flags & FLAG_EXE) == 0) {
                 /*
                 * http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044d/IHI0044D_aaelf.pdf
                 *
@@ -1490,7 +1490,7 @@ int soinfo::Relocate(ElfW(Rel)* rel, unsigned count) {
                 * We should explicitly disallow ET_DYN executables from having
                 * R_ARM_COPY relocations.
                 */
-                DL_ERR("%s R_ARM_COPY relocations only supported for ET_EXEC", si->name);
+                DL_ERR("%s R_ARM_COPY relocations only supported for ET_EXEC", name);
                 return -1;
             }
             count_relocation(kRelocCopy);
@@ -1500,23 +1500,23 @@ int soinfo::Relocate(ElfW(Rel)* rel, unsigned count) {
                 ElfW(Sym)* src = soinfo_do_lookup(NULL, sym_name, &lsi, needed);
 
                 if (src == NULL) {
-                    DL_ERR("%s R_ARM_COPY relocation source cannot be resolved", si->name);
+                    DL_ERR("%s R_ARM_COPY relocation source cannot be resolved", name);
                     return -1;
                 }
                 if (lsi->has_DT_SYMBOLIC) {
                     DL_ERR("%s invalid R_ARM_COPY relocation against DT_SYMBOLIC shared "
-                           "library %s (built with -Bsymbolic?)", si->name, lsi->name);
+                           "library %s (built with -Bsymbolic?)", name, lsi->name);
                     return -1;
                 }
                 if (s->st_size < src->st_size) {
                     DL_ERR("%s R_ARM_COPY relocation size mismatch (%d < %d)",
-                           si->name, s->st_size, src->st_size);
+                           name, s->st_size, src->st_size);
                     return -1;
                 }
                 memcpy(reinterpret_cast<void*>(reloc),
                        reinterpret_cast<void*>(src->st_value + lsi->load_bias), src->st_size);
             } else {
-                DL_ERR("%s R_ARM_COPY relocation target cannot be resolved", si->name);
+                DL_ERR("%s R_ARM_COPY relocation target cannot be resolved", name);
                 return -1;
             }
             break;
-- 
1.9.1


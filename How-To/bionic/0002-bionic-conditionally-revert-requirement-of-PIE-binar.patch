From e9f02a39d6b0a2bf55aa6caad24ac82dcee2502f Mon Sep 17 00:00:00 2001
From: Kyle Repinski <repinski23@gmail.com>
Date: Tue, 2 Dec 2014 17:09:37 -0200
Subject: [PATCH 2/4] bionic: conditionally revert requirement of PIE binaries

Signed-off-by: Humberto Borba <humberos@gmail.com>
Change-Id: I847cc4f45f41c8913bcb811bca412fa6d1ca8685

Conflicts:
	linker/Android.mk
	linker/linker.cpp
---
 linker/Android.mk |  4 ++++
 linker/linker.cpp | 71 +++++++++++++++++++++++++++++++++++++++++++++----------
 2 files changed, 63 insertions(+), 12 deletions(-)

diff --git a/linker/Android.mk b/linker/Android.mk
index 5727e64..fa97bc7 100644
--- a/linker/Android.mk
+++ b/linker/Android.mk
@@ -40,6 +40,10 @@ ifeq ($(TARGET_NEEDS_BIONIC_PRELINK_SUPPORT),true)
     LOCAL_CFLAGS += -DENABLE_PRELINK_SUPPORT
 endif
 
+ifeq ($(TARGET_ENABLE_NON_PIE_SUPPORT),true)
+    LOCAL_CFLAGS += -DENABLE_NON_PIE_SUPPORT
+endif
+
 # We need to access Bionic private headers in the linker.
 LOCAL_CFLAGS += -I$(LOCAL_PATH)/../libc/
 
diff --git a/linker/linker.cpp b/linker/linker.cpp
index 54867dc..e92390f 100644
--- a/linker/linker.cpp
+++ b/linker/linker.cpp
@@ -1464,18 +1464,63 @@ int soinfo::Relocate(ElfW(Rel)* rel, unsigned count) {
                    reloc, sym_addr, rel->r_offset, sym_name);
         *reinterpret_cast<ElfW(Addr)*>(reloc) += sym_addr - rel->r_offset;
         break;
-      case R_ARM_COPY:
-        /*
-         * ET_EXEC is not supported so this should not happen.
-         *
-         * http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044d/IHI0044D_aaelf.pdf
-         *
-         * Section 4.7.1.10 "Dynamic relocations"
-         * R_ARM_COPY may only appear in executable objects where e_type is
-         * set to ET_EXEC.
-         */
-        DL_ERR("%s R_ARM_COPY relocations are not supported", name);
-        return -1;
+        case R_ARM_COPY:
+#ifndef ENABLE_NON_PIE_SUPPORT
+            /*
+             * ET_EXEC is not supported so this should not happen.
+             *
+             * http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044d/IHI0044D_aaelf.pdf
+             *
+             * Section 4.7.1.10 "Dynamic relocations"
+             * R_ARM_COPY may only appear in executable objects where e_type is
+             * set to ET_EXEC.
+             */
+            DL_ERR("%s R_ARM_COPY relocations are not supported", si->name);
+            return -1;
+#else
+            if ((si->flags & FLAG_EXE) == 0) {
+                /*
+                * http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044d/IHI0044D_aaelf.pdf
+                *
+                * Section 4.7.1.10 "Dynamic relocations"
+                * R_ARM_COPY may only appear in executable objects where e_type is
+                * set to ET_EXEC.
+                *
+                * TODO: FLAG_EXE is set for both ET_DYN and ET_EXEC executables.
+                * We should explicitly disallow ET_DYN executables from having
+                * R_ARM_COPY relocations.
+                */
+                DL_ERR("%s R_ARM_COPY relocations only supported for ET_EXEC", si->name);
+                return -1;
+            }
+            count_relocation(kRelocCopy);
+            MARK(rel->r_offset);
+            TRACE_TYPE(RELO, "RELO %08x <- %d @ %08x %s", reloc, s->st_size, sym_addr, sym_name);
+            if (reloc == sym_addr) {
+                ElfW(Sym)* src = soinfo_do_lookup(NULL, sym_name, &lsi, needed);
+
+                if (src == NULL) {
+                    DL_ERR("%s R_ARM_COPY relocation source cannot be resolved", si->name);
+                    return -1;
+                }
+                if (lsi->has_DT_SYMBOLIC) {
+                    DL_ERR("%s invalid R_ARM_COPY relocation against DT_SYMBOLIC shared "
+                           "library %s (built with -Bsymbolic?)", si->name, lsi->name);
+                    return -1;
+                }
+                if (s->st_size < src->st_size) {
+                    DL_ERR("%s R_ARM_COPY relocation size mismatch (%d < %d)",
+                           si->name, s->st_size, src->st_size);
+                    return -1;
+                }
+                memcpy(reinterpret_cast<void*>(reloc),
+                       reinterpret_cast<void*>(src->st_value + lsi->load_bias), src->st_size);
+            } else {
+                DL_ERR("%s R_ARM_COPY relocation target cannot be resolved", si->name);
+                return -1;
+            }
+            break;
+#endif
 #elif defined(__i386__)
       case R_386_JMP_SLOT:
         count_relocation(kRelocAbsolute);
@@ -2401,11 +2446,13 @@ static ElfW(Addr) __linker_init_post_relocation(KernelArgumentBlock& args, ElfW(
   si->dynamic = nullptr;
   si->ref_count = 1;
 
+#ifndef ENABLE_NON_PIE_SUPPORT
   ElfW(Ehdr)* elf_hdr = reinterpret_cast<ElfW(Ehdr)*>(si->base);
   if (elf_hdr->e_type != ET_DYN) {
     __libc_format_fd(2, "error: only position independent executables (PIE) are supported.\n");
     exit(EXIT_FAILURE);
   }
+#endif
 
   // Use LD_LIBRARY_PATH and LD_PRELOAD (but only if we aren't setuid/setgid).
   parse_LD_LIBRARY_PATH(ldpath_env);
-- 
1.9.1

